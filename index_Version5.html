<!doctype html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Московское время</title>

  <style>
    :root{
      --bg:#000;
      --text:#fff;
      --fx: rgba(255,255,255,0.16);
      --accent: rgba(120,200,255,0.55);
      --panel: rgba(255,255,255,0.14);
      --panel2: rgba(0,0,0,0.22);
      color-scheme: dark;
    }

    html, body { height: 100%; margin: 0; overflow: hidden; }
    body{
      background: var(--bg);
      color: var(--text);
      display: grid;
      place-items: center;
      font-family: -apple-system, BlinkMacSystemFont,
        "SF Pro Display", "SF Pro Text",
        system-ui, "Segoe UI", Roboto, Arial, sans-serif;
      -webkit-font-smoothing: antialiased;
      text-rendering: optimizeLegibility;
    }

    #bg {
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
      display: block;
    }

    .center {
      position: relative;
      z-index: 1;
      text-align: center;
      user-select: none;
      padding: 24px;
    }

    #time {
      font-weight: 600;
      font-size: clamp(48px, 12vw, 140px);
      letter-spacing: -0.04em;
      font-variant-numeric: tabular-nums;
      line-height: 1;
      cursor: pointer;
    }

    #date {
      margin-top: 12px;
      font-size: clamp(16px, 3vw, 28px);
      opacity: 0.75;
      letter-spacing: -0.01em;
      transition: opacity 160ms ease;
    }
    #focusFloating{
      position: absolute;
      left: 50%;
      top: 0;
      transform: translate(-50%, -110%);
      padding: 4px 10px;
      border-radius: 999px;
      background: rgba(0,0,0,0.28);
      box-shadow: 0 0 0 1px rgba(255,255,255,0.08) inset;
      font-size: clamp(11px, 1.7vw, 14px);
      letter-spacing: 0.01em;
      opacity: 0;
      pointer-events: none;
      transition: opacity 160ms ease;
    }
    #focusFloating.active{ opacity: 0.9; }

    /* Панель */
    .controls-wrap {
      position: fixed;
      top: 12px;
      left: 12px;
      z-index: 3;
    }

    .controls {
      position: absolute;
      top: 0;
      left: 0;
      width: 360px;
      padding: 12px;
      border-radius: 14px;
      background: var(--panel);
      backdrop-filter: blur(12px);
      opacity: 1;
      transform: none;
      pointer-events: auto;
      font-size: 12px;
    }

    .row{
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      margin: 8px 0;
    }

    .title{
      font-weight: 600;
      opacity: 0.85;
      margin: 10px 0 6px;
    }

    .seg{
      display: inline-flex;
      background: var(--panel2);
      border-radius: 12px;
      padding: 3px;
      gap: 3px;
    }
    .seg button{
      border: 0;
      background: transparent;
      color: rgba(255,255,255,0.88);
      padding: 6px 10px;
      border-radius: 10px;
      cursor: pointer;
      font: inherit;
    }
    .seg button.active{
      background: rgba(255,255,255,0.18);
      color: rgba(255,255,255,0.97);
      box-shadow: 0 0 0 1px rgba(255,255,255,0.08) inset;
    }

    .small-btn{
      border: 0;
      cursor: pointer;
      border-radius: 10px;
      padding: 6px 10px;
      background: var(--panel2);
      color: rgba(255,255,255,0.92);
      font: inherit;
      white-space: nowrap;
    }

    .controls label{
      display:flex;
      align-items:center;
      gap:8px;
      cursor:pointer;
      opacity: .95;
    }

    input[type="color"]{
      width: 30px;
      height: 30px;
      padding: 0;
      border: none;
      background: none;
      cursor: pointer;
    }

    select, input[type="time"], input[type="number"]{
      width: 100%;
      box-sizing: border-box;
      border: 0;
      outline: none;
      border-radius: 12px;
      padding: 9px 10px;
      background: var(--panel2);
      color: rgba(255,255,255,0.92);
      font: inherit;
    }


    .hint{
      opacity: 0.65;
      font-size: 11px;
      margin-top: 8px;
      line-height: 1.25;
    }

    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding: 7px 10px;
      border-radius: 999px;
      background: rgba(0,0,0,0.20);
      box-shadow: 0 0 0 1px rgba(255,255,255,0.06) inset;
      opacity: .95;
    }

    .checkbox{
      display:flex;
      align-items:center;
      gap:10px;
      justify-content: space-between;
      margin: 6px 0;
    }

    .checkbox input{ transform: scale(1.05); }

    /* Focus overlay */
    .overlay{
      position: fixed;
      inset: 0;
      z-index: 10;
      display: none;
      place-items: center;
      background: rgba(0,0,0,0.35);
      backdrop-filter: blur(12px);
    }
    .overlay.open{ display: grid; }

    .modal{
      width: min(520px, calc(100vw - 28px));
      border-radius: 20px;
      padding: 16px;
      background: rgba(255,255,255,0.12);
      box-shadow: 0 20px 60px rgba(0,0,0,0.35);
      backdrop-filter: blur(14px);
    }

    .modal h3{
      margin: 0 0 8px;
      font-size: 14px;
      opacity: .95;
    }

    .modal .big{
      font-size: clamp(44px, 8vw, 72px);
      font-weight: 650;
      letter-spacing: -0.04em;
      font-variant-numeric: tabular-nums;
      line-height: 1.1;
      margin: 6px 0 8px;
      text-align: center;
    }

    .modal .bar{
      height: 8px;
      border-radius: 999px;
      background: rgba(255,255,255,0.10);
      overflow: hidden;
      margin: 8px 0 12px;
    }
    .modal .bar > div{
      height: 100%;
      width: 0%;
      background: var(--accent);
    }

    .modal .grid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-top: 10px;
    }

    .modal .grid .small-btn{ padding: 10px 12px; border-radius: 14px; }

    @media (prefers-reduced-motion: reduce) {
      .controls { transition: none; }
    }
  </style>
</head>

<body>
  <canvas id="bg"></canvas>

  <div class="controls-wrap">
    <div class="controls" aria-label="Настройки">
      <!-- THEME -->
      <div class="title">Theme (MSK)</div>
      <div class="row">
        <div class="seg" role="tablist" aria-label="Theme">
          <button id="modeAuto" type="button">Auto</button>
          <button id="modeDay" type="button">Day</button>
          <button id="modeNight" type="button">Night</button>
        </div>
        <button id="reset" class="small-btn" type="button">Reset</button>
      </div>

      <div class="row">
        <label class="pill">Day BG <input type="color" id="dayBg"></label>
        <label class="pill">Day TXT <input type="color" id="dayText"></label>
      </div>
      <div class="row">
        <label class="pill">Night BG <input type="color" id="nightBg"></label>
        <label class="pill">Night TXT <input type="color" id="nightText"></label>
      </div>

      <!-- VISUAL -->
      <div class="title">Visual</div>
      <div class="row">
        <label style="flex:1;">
          Scene
          <select id="scene">
            <option value="space">Space</option>
            <option value="fog">Fog</option>
            <option value="grid">Grid</option>
            <option value="liquid">Liquid</option>
          </select>
        </label>
      </div>

      <div class="row">
        <label style="flex:1;">
          Cursor
          <select id="cursorMode">
            <option value="magnet">Magnet</option>
            <option value="swirl">Swirl</option>
            <option value="repulse">Repulse</option>
            <option value="jelly">Jelly</option>
          </select>
        </label>
      </div>

      <div class="checkbox">
        <label>Draw waves (hold click)</label>
        <input id="drawWaves" type="checkbox">
      </div>

      <div class="checkbox">
        <label>Minimal mode</label>
        <input id="minimal" type="checkbox">
      </div>

      <div class="checkbox">
        <label>Night chill after 22:00</label>
        <input id="nightChill" type="checkbox">
      </div>

      <div class="checkbox">
        <label>Pause animation</label>
        <input id="pauseAnim" type="checkbox">
      </div>

      <!-- Disable effects (kept from earlier change) -->
      <div class="checkbox">
        <label>Disable effects</label>
        <input id="disableEffects" type="checkbox">
      </div>

      <!-- TIME -->
      <div class="title">Time extras</div>

      <!-- NEW: Day/Night switch times + transition duration -->
      <div class="row">
        <label style="flex:1;">
          Day start (MSK)
          <input id="dayStartTime" type="time" />
        </label>
      </div>
      <div class="row">
        <label style="flex:1;">
          Night start (MSK)
          <input id="nightStartTime" type="time" />
        </label>
      </div>
      <div class="row">
        <label style="flex:1;">
          Transition (seconds)
          <input id="transitionSeconds" type="number" min="0" max="600" />
        </label>
      </div>

      <!-- FOCUS -->
      <div class="title">Focus</div>
      <div class="row">
        <button id="openFocus" class="small-btn" type="button">Open timer</button>
      </div>

      <!-- ACCENT -->
      <div class="title">Accent</div>
      <div class="row">
        <button id="regenAccent" class="small-btn" type="button">New accent</button>
        <label class="pill" style="gap:10px;">
          Lock
          <input id="lockAccent" type="checkbox" />
        </label>
      </div>

      <div class="hint">
        • Click background → wave<br>
        • Hold click (if enabled) → draw waves<br>
        • Double-click time → open Focus timer
      </div>
    </div>
  </div>

  <div class="center" id="center">
    <div id="focusFloating" aria-live="polite"></div>
    <div id="time" title="Double-click to open Focus timer">--:--:--</div>
    <div id="date">—</div>
  </div>

  <!-- Focus modal -->
  <div class="overlay" id="overlay">
    <div class="modal">
      <div class="row" style="margin:0 0 6px;">
        <h3 style="margin:0;">Focus Timer</h3>
        <button id="closeFocus" class="small-btn" type="button">Close</button>
      </div>

      <div class="big" id="focusDisplay">25:00</div>
      <div class="bar"><div id="focusBar"></div></div>

      <div class="row">
        <button id="focusStart" class="small-btn" type="button">Start</button>
        <button id="focusPause" class="small-btn" type="button">Pause</button>
        <button id="focusReset" class="small-btn" type="button">Reset</button>
      </div>

      <div class="grid">
        <button class="small-btn" data-preset="5">Break 5</button>
        <button class="small-btn" data-preset="15">Break 15</button>
      </div>

      <div class="hint" style="margin-top:10px;">
        Во время Focus фон становится спокойнее. По завершении — мягкая волна + вспышка.
      </div>
    </div>
  </div>

  <script>
    // =========================
    // Utils
    // =========================
    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
    const lerp = (a, b, t) => a + (b - a) * t;

    function hexToRgb(hex) {
      const m = String(hex).replace("#","").match(/.{1,2}/g);
      if (!m) return {r:255,g:255,b:255};
      const [r,g,b] = m.map(x => parseInt(x, 16));
      return {r,g,b};
    }

    function rgbToHex({r,g,b}){
      const rh = Math.round(r).toString(16).padStart(2,"0");
      const gh = Math.round(g).toString(16).padStart(2,"0");
      const bh = Math.round(b).toString(16).padStart(2,"0");
      return `#${rh}${gh}${bh}`;
    }

    function mixRgb(a, b, t){
      return { r: lerp(a.r,b.r,t), g: lerp(a.g,b.g,t), b: lerp(a.b,b.b,t) };
    }

    function rgbaFromCssVar(varName, alphaOverride=null){
      const v = getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
      const m = v.match(/rgba?\(([^)]+)\)/);
      if (!m) return `rgba(255,255,255,${alphaOverride ?? 0.2})`;
      const parts = m[1].split(",").map(s => s.trim());
      const r = parts[0] ?? "255";
      const g = parts[1] ?? "255";
      const b = parts[2] ?? "255";
      const a = alphaOverride ?? (parts[3] ?? "0.2");
      return `rgba(${r},${g},${b},${a})`;
    }

    // ======================
    // Settings
    // ======================
    const KEY = "mskClockAll_v1";

    const defaults = {
      themeMode: "auto", // auto|day|night
      day:   { bg: "#f3f5f7", text: "#0b0b0c" },
      night: { bg: "#000000", text: "#ffffff" },
      // replace hours with times (HH:MM) for precise switching
      dayStartTime: "07:00",
      nightStartTime: "21:00",
      transitionSeconds: 12, // duration of smooth transition (seconds)

      scene: "space",       // space|fog|grid|liquid
      cursorMode: "magnet", // magnet|swirl|repulse|jelly
      drawWaves: true,
      minimal: false,
      nightChill: true,
      pauseAnim: false,

      disableEffects: false,

      accentLocked: false,
      accentRgba: null, // stored as "rgba(r,g,b,a)" or null
    };

    function loadSettings(){
      try{
        const raw = localStorage.getItem(KEY);
        if(!raw) return structuredClone(defaults);
        const s = JSON.parse(raw);
        if (s.transitionSeconds == null && Number.isFinite(s.transitionMinutes)) {
          s.transitionSeconds = s.transitionMinutes * 60;
        }
        return {
          ...structuredClone(defaults),
          ...s,
          day: { ...structuredClone(defaults.day), ...(s.day||{}) },
          night: { ...structuredClone(defaults.night), ...(s.night||{}) },
        };
      }catch{
        return structuredClone(defaults);
      }
    }

    let settings = loadSettings();
    function saveSettings(){ localStorage.setItem(KEY, JSON.stringify(settings)); }

    // runtime storage for restoring effects after temporarily disabling
    let _savedEffects = null;

    // ======================
    // Theme + Accent + Smooth switching
    // ======================
    function moscowParts() {
      const now = new Date();
      const parts = new Intl.DateTimeFormat("ru-RU", {
        timeZone: "Europe/Moscow",
        hour: "2-digit", minute: "2-digit", second: "2-digit",
        hour12: false
      }).formatToParts(now);
      const get = (t) => parts.find(p => p.type === t)?.value ?? "00";
      return { h: parseInt(get("hour"),10), m: parseInt(get("minute"),10), s: parseInt(get("second"),10), now };
    }

    // parse "HH:MM" -> total seconds
    function hhmmToSec(hhmm){
      if (!hhmm || typeof hhmm !== "string") return 0;
      const [hh,mm] = hhmm.split(":").map(Number);
      if (Number.isFinite(hh) && Number.isFinite(mm)) return ((hh % 24) * 3600) + ((mm % 60) * 60);
      return 0;
    }
    // check if x in interval [a,b) on circular 0..86400
    function inInterval(x,a,b){
      if (a <= b) return x >= a && x < b;
      return x >= a || x < b; // wraps
    }

    // compute blend 0..1: 0 => night, 1 => day
    function computeAutoBlend(){
      const { h, m, s } = moscowParts();
      const nowSec = h*3600 + m*60 + s;
      const ds = hhmmToSec(settings.dayStartTime || defaults.dayStartTime);
      const ns = hhmmToSec(settings.nightStartTime || defaults.nightStartTime);
      const tSec = Math.max(0, Math.min(600, Number(settings.transitionSeconds) || defaults.transitionSeconds));
      const half = tSec / 2;

      // Morning transition centered at ds: night -> day
      const morningStart = (ds - half + 86400) % 86400;
      const morningEnd   = (ds + half) % 86400;

      // Evening transition centered at ns: day -> night
      const eveningStart = (ns - half + 86400) % 86400;
      const eveningEnd   = (ns + half) % 86400;

      // If time is within full day (excluding transition windows) => day (1)
      const dayBodyStart = morningEnd;
      const dayBodyEnd = eveningStart;

      if (inInterval(nowSec, morningEnd, eveningStart)){
        return 1; // fully day
      }
      // fully night between eveningEnd and morningStart
      if (inInterval(nowSec, eveningEnd, morningStart)){
        return 0; // fully night
      }

      // check if inside morning transition window (night->day)
      if (inInterval(nowSec, morningStart, morningEnd)){
        // compute progress 0..1 across [morningStart..morningEnd)
        let len = (morningEnd - morningStart + 86400) % 86400;
        if (len === 0) return 1;
        let pos = (nowSec - morningStart + 86400) % 86400;
        return clamp(pos / len, 0, 1);
      }

      // check evening transition window (day->night)
      if (inInterval(nowSec, eveningStart, eveningEnd)){
        let len = (eveningEnd - eveningStart + 86400) % 86400;
        if (len === 0) return 0;
        let pos = (nowSec - eveningStart + 86400) % 86400;
        // evening transition goes from 1 -> 0
        return clamp(1 - (pos / len), 0, 1);
      }

      // fallback
      return (inInterval(nowSec, ds, ns)) ? 1 : 0;
    }

    function setCssTheme(bgHex, textHex){
      document.documentElement.style.setProperty("--bg", bgHex);
      document.documentElement.style.setProperty("--text", textHex);

      const {r,g,b} = hexToRgb(textHex);
      document.documentElement.style.setProperty("--fx", `rgba(${r},${g},${b},0.16)`);

      const luminance = (0.2126*r + 0.7152*g + 0.0722*b) / 255;
      document.documentElement.style.colorScheme = luminance < 0.5 ? "dark" : "light";
    }

    // set theme by blending day/night colors according to t (0..1)
    function setCssThemeBlend(dayBgHex, dayTextHex, nightBgHex, nightTextHex, t){
      const dayBg = hexToRgb(dayBgHex);
      const dayTxt = hexToRgb(dayTextHex);
      const nightBg = hexToRgb(nightBgHex);
      const nightTxt = hexToRgb(nightTextHex);
      const mixBg = mixRgb(nightBg, dayBg, t);
      const mixTxt = mixRgb(nightTxt, dayTxt, t);
      setCssTheme(rgbToHex(mixBg), rgbToHex(mixTxt));
    }

    function hashDateSeed(){
      const d = new Intl.DateTimeFormat("en-CA", { timeZone:"Europe/Moscow", year:"numeric", month:"2-digit", day:"2-digit" }).format(new Date());
      let h = 2166136261;
      for (let i=0;i<d.length;i++){
        h ^= d.charCodeAt(i);
        h = Math.imul(h, 16777619);
      }
      return (h>>>0);
    }

    function makeAccentFromSeed(seed){
      // pastel-ish accent
      const r = 90 + (seed % 120);
      const g = 120 + ((seed>>7) % 110);
      const b = 150 + ((seed>>14) % 100);
      return `rgba(${clamp(r,0,255)},${clamp(g,0,255)},${clamp(b,0,255)},0.55)`;
    }

    function applyAccent(){
      if (settings.accentRgba) {
        document.documentElement.style.setProperty("--accent", settings.accentRgba);
      } else {
        document.documentElement.style.setProperty("--accent", makeAccentFromSeed(hashDateSeed()));
      }
    }

    function applyAll(){
      const mode = settings.themeMode;
      if (mode === "auto"){
        const blend = computeAutoBlend(); // 0..1
        // use blend to interpolate between night (0) and day (1)
        setCssThemeBlend(settings.day.bg, settings.day.text, settings.night.bg, settings.night.text, blend);
      } else {
        const themeName = mode;
        const theme = settings[themeName];
        setCssTheme(theme.bg, theme.text);
      }
      applyAccent();
      applyMinimalUI();
      refreshUI();
    }

    // ======================
    // Clock UI
    // ======================
    const timeEl = document.getElementById("time");
    const dateEl = document.getElementById("date");
    const focusFloating = document.getElementById("focusFloating");

    // Helper: format time for tz. If tz === "local", omit timeZone -> local system time.
    function fmtTime(tz){
      if (tz === "local" || !tz) {
        return new Intl.DateTimeFormat("ru-RU", {
          hour: "2-digit", minute: "2-digit", second: "2-digit",
          hour12: false
        }).format(new Date());
      }
      return new Intl.DateTimeFormat("ru-RU", {
        timeZone: tz,
        hour: "2-digit", minute: "2-digit", second: "2-digit",
        hour12: false
      }).format(new Date());
    }

    function fmtDate(){
      return new Intl.DateTimeFormat("ru-RU", {
        timeZone: "Europe/Moscow",
        weekday: "long", day: "numeric", month: "long", year: "numeric"
      }).format(new Date());
    }

    function updateClock(){
      // display is MSK fixed as before
      timeEl.textContent = fmtTime("Europe/Moscow");
      dateEl.textContent = fmtDate();
    }

    updateClock();
    setTimeout(() => {
      updateClock();
      setInterval(updateClock, 1000);
    }, 1000 - (Date.now() % 1000));

    // ======================
    // Controls wiring
    // ======================
    const modeAutoBtn  = document.getElementById("modeAuto");
    const modeDayBtn   = document.getElementById("modeDay");
    const modeNightBtn = document.getElementById("modeNight");
    const resetBtn = document.getElementById("reset");

    const dayBg    = document.getElementById("dayBg");
    const dayText  = document.getElementById("dayText");
    const nightBg  = document.getElementById("nightBg");
    const nightText= document.getElementById("nightText");

    const sceneSel = document.getElementById("scene");
    const cursorSel = document.getElementById("cursorMode");
    const drawWavesChk = document.getElementById("drawWaves");
    const minimalChk = document.getElementById("minimal");
    const nightChillChk = document.getElementById("nightChill");
    const pauseAnimChk = document.getElementById("pauseAnim");

    const disableEffectsChk = document.getElementById("disableEffects");

    // NEW controls
    const dayStartTimeInp = document.getElementById("dayStartTime");
    const nightStartTimeInp = document.getElementById("nightStartTime");
    const transitionSecondsInp = document.getElementById("transitionSeconds");

    const regenAccentBtn = document.getElementById("regenAccent");
    const lockAccentChk = document.getElementById("lockAccent");

    function refreshUI(){
      modeAutoBtn.classList.toggle("active", settings.themeMode==="auto");
      modeDayBtn.classList.toggle("active", settings.themeMode==="day");
      modeNightBtn.classList.toggle("active", settings.themeMode==="night");

      dayBg.value = settings.day.bg;
      dayText.value = settings.day.text;
      nightBg.value = settings.night.bg;
      nightText.value = settings.night.text;

      sceneSel.value = settings.scene;
      cursorSel.value = settings.cursorMode;
      drawWavesChk.checked = !!settings.drawWaves;
      minimalChk.checked = !!settings.minimal;
      nightChillChk.checked = !!settings.nightChill;
      pauseAnimChk.checked = !!settings.pauseAnim;

      lockAccentChk.checked = !!settings.accentLocked;

      disableEffectsChk.checked = !!settings.disableEffects;

      // NEW: fill time inputs
      dayStartTimeInp.value = settings.dayStartTime || defaults.dayStartTime;
      nightStartTimeInp.value = settings.nightStartTime || defaults.nightStartTime;
      transitionSecondsInp.value = Number(settings.transitionSeconds || defaults.transitionSeconds);
    }

    function applyMinimalUI(){
      const minimal = !!settings.minimal;
      dateEl.style.display = minimal ? "none" : "";
    }

    function setMode(m){ settings.themeMode=m; saveSettings(); applyAll(); }
    modeAutoBtn.addEventListener("click", ()=>setMode("auto"));
    modeDayBtn.addEventListener("click", ()=>setMode("day"));
    modeNightBtn.addEventListener("click", ()=>setMode("night"));

    dayBg.addEventListener("input", e=>{ settings.day.bg=e.target.value; saveSettings(); applyAll(); });
    dayText.addEventListener("input", e=>{ settings.day.text=e.target.value; saveSettings(); applyAll(); });
    nightBg.addEventListener("input", e=>{ settings.night.bg=e.target.value; saveSettings(); applyAll(); });
    nightText.addEventListener("input", e=>{ settings.night.text=e.target.value; saveSettings(); applyAll(); });

    sceneSel.addEventListener("change", e=>{ settings.scene=e.target.value; saveSettings(); });
    cursorSel.addEventListener("change", e=>{ settings.cursorMode=e.target.value; saveSettings(); });

    drawWavesChk.addEventListener("change", e=>{ settings.drawWaves=!!e.target.checked; saveSettings(); });
    minimalChk.addEventListener("change", e=>{ settings.minimal=!!e.target.checked; saveSettings(); applyAll(); });
    nightChillChk.addEventListener("change", e=>{ settings.nightChill=!!e.target.checked; saveSettings(); });
    pauseAnimChk.addEventListener("change", e=>{ settings.pauseAnim=!!e.target.checked; saveSettings(); });

    disableEffectsChk.addEventListener("change", e=>{
      const turnOn = !!e.target.checked;
      settings.disableEffects = turnOn;
      if (turnOn){
        _savedEffects = { pauseAnim: settings.pauseAnim, drawWaves: settings.drawWaves, scene: settings.scene, cursorMode: settings.cursorMode };
        settings.pauseAnim = true;
        settings.drawWaves = false;
      } else {
        if (_savedEffects){
          settings.pauseAnim = !!_savedEffects.pauseAnim;
          settings.drawWaves = !!_savedEffects.drawWaves;
          settings.scene = _savedEffects.scene || settings.scene;
          settings.cursorMode = _savedEffects.cursorMode || settings.cursorMode;
        }
        _savedEffects = null;
      }
      saveSettings();
      applyAll();
    });

    // NEW: switching time inputs
    dayStartTimeInp.addEventListener("change", e=>{
      settings.dayStartTime = e.target.value || defaults.dayStartTime;
      saveSettings();
      applyAll();
    });
    nightStartTimeInp.addEventListener("change", e=>{
      settings.nightStartTime = e.target.value || defaults.nightStartTime;
      saveSettings();
      applyAll();
    });
    transitionSecondsInp.addEventListener("change", e=>{
      let v = parseInt(e.target.value,10);
      if (!Number.isFinite(v) || v < 0) v = defaults.transitionSeconds;
      settings.transitionSeconds = v;
      saveSettings();
      applyAll();
    });

    resetBtn.addEventListener("click", ()=>{
      settings = structuredClone(defaults);
      saveSettings();
      applyAll();
    });

    regenAccentBtn.addEventListener("click", ()=>{
      // generate random pastel accent and store
      const r = 90 + Math.floor(Math.random()*140);
      const g = 110 + Math.floor(Math.random()*130);
      const b = 140 + Math.floor(Math.random()*110);
      settings.accentRgba = `rgba(${clamp(r,0,255)},${clamp(g,0,255)},${clamp(b,0,255)},0.55)`;
      settings.accentLocked = true;
      saveSettings();
      applyAll();
    });

    lockAccentChk.addEventListener("change", e=>{
      settings.accentLocked = !!e.target.checked;
      if (!settings.accentLocked) settings.accentRgba = null; // back to daily
      saveSettings();
      applyAll();
    });


    // Auto refresh theme
    setInterval(()=>{ if (settings.themeMode==="auto") applyAll(); }, 10_000);

    // Night chill auto affects physics only, no UI changes
    function isNightChillNow(){
      if (!settings.nightChill) return false;
      const { h } = moscowParts();
      return (h >= 22 || h < 7);
    }

    // ======================
    // Focus timer
    // ======================
    const overlay = document.getElementById("overlay");
    const openFocus = document.getElementById("openFocus");
    const closeFocus = document.getElementById("closeFocus");
    const focusDisplay = document.getElementById("focusDisplay");
    const focusBar = document.getElementById("focusBar");
    const focusStart = document.getElementById("focusStart");
    const focusPause = document.getElementById("focusPause");
    const focusReset = document.getElementById("focusReset");

    let focusTotal = 25*60;
    let focusLeft  = focusTotal;
    let focusRunning = false;
    let focusTick = null;

    function fmtMMSS(sec){
      sec = Math.max(0, Math.floor(sec));
      const m = Math.floor(sec/60);
      const s = sec%60;
      return `${String(m).padStart(2,"0")}:${String(s).padStart(2,"0")}`;
    }

    function updateFocusUI(){
      focusDisplay.textContent = fmtMMSS(focusLeft);
      const p = focusTotal > 0 ? (1 - focusLeft/focusTotal) : 0;
      focusBar.style.width = `${clamp(p*100,0,100)}%`;
      updateFocusIndicator();
    }

    function setFocusPreset(min){
      focusTotal = min*60;
      focusLeft = focusTotal;
      focusRunning = false;
      if (focusTick) { clearInterval(focusTick); focusTick=null; }
      updateFocusUI();
    }

    function openFocusModal(){
      overlay.classList.add("open");
      updateFocusUI();
    }
    function closeFocusModal(){
      overlay.classList.remove("open");
    }

    openFocus.addEventListener("click", openFocusModal);
    closeFocus.addEventListener("click", closeFocusModal);
    overlay.addEventListener("click", (e)=>{ if (e.target === overlay) closeFocusModal(); });

    timeEl.addEventListener("dblclick", openFocusModal);

    document.querySelectorAll('[data-preset]').forEach(btn=>{
      btn.addEventListener("click", ()=>{
        setFocusPreset(parseInt(btn.dataset.preset,10));
      });
    });

    focusStart.addEventListener("click", ()=>{
      if (focusRunning) return;
      focusRunning = true;
      if (focusTick) clearInterval(focusTick);
      focusTick = setInterval(()=>{
        if (!focusRunning) return;
        focusLeft -= 1;
        if (focusLeft <= 0){
          focusLeft = 0;
          focusRunning = false;
          clearInterval(focusTick); focusTick=null;
          // completion effect: wave burst in center
          addWave(w*0.5, h*0.5, 1400);
          flash = 1.0;
        }
        updateFocusUI();
      }, 1000);
      updateFocusIndicator();
    });

    focusPause.addEventListener("click", ()=>{
      focusRunning = false;
      updateFocusIndicator();
    });

    focusReset.addEventListener("click", ()=>{
      focusLeft = focusTotal;
      focusRunning = false;
      updateFocusUI();
    });

    function updateFocusIndicator(){
      const active = focusRunning && focusLeft > 0;
      focusFloating.textContent = active ? `⏱ ${fmtMMSS(focusLeft)}` : "";
      focusFloating.classList.toggle("active", active);
    }

    // ======================
    // Canvas: scenes + cursor modes + waves
    // ======================
    const canvas = document.getElementById("bg");
    const ctx = canvas.getContext("2d", { alpha: true });

    let w = 0, h = 0, dpr = 1;
    function resize(){
      w = window.innerWidth;
      h = window.innerHeight;
      dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      canvas.width = Math.floor(w * dpr);
      canvas.height = Math.floor(h * dpr);
      canvas.style.width = w + "px";
      canvas.style.height = h + "px";
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    window.addEventListener("resize", resize);
    resize();

    const mouse = { x: w*0.5, y: h*0.5, active: false, down: false };
    window.addEventListener("pointermove", (e)=>{ mouse.x=e.clientX; mouse.y=e.clientY; mouse.active=true; });
    window.addEventListener("pointerleave", ()=>{ mouse.active=false; mouse.down=false; });
    window.addEventListener("pointerdown", (e)=>{
      const el = document.elementFromPoint(e.clientX, e.clientY);
      if (el && el.closest && el.closest(".controls-wrap")) return;
      mouse.down = true;
      addWave(e.clientX, e.clientY, 900);
    });
    window.addEventListener("pointerup", ()=>{ mouse.down=false; });

    // Waves
    const waves = [];
    function addWave(x,y,strength=900){
      if (settings.disableEffects) return; // block waves when effects disabled
      waves.push({ x,y, r:0, speed: 520, width: 12, strength, life:0, maxLife: 1.1 });
    }

    // Flash on focus complete
    let flash = 0;

    function particleCount(){
      const area = w*h;
      return Math.max(55, Math.min(160, Math.floor(area/15000)));
    }

    let particles = [];
    function initParticles(){
      const n = particleCount();
      particles = Array.from({ length: n }, ()=>({
        x: Math.random()*w,
        y: Math.random()*h,
        vx: (Math.random()-0.5)*0.08,
        vy: (Math.random()-0.5)*0.08,
        r: 1.1 + Math.random()*1.8,
        // jelly anchor
        ax: 0,
        ay: 0,
      }));
    }
    initParticles();

    function sceneParams(){
      // base
      const base = {
        lines: true,
        grid: false,
        fog: false,
        flow: false,
        linkDist: 150,
        pointAlpha: 0.22,
        lineAlpha: 0.10,
        drift: 0.06,
      };

      if (settings.scene === "fog"){
        return { ...base, lines:false, fog:true, linkDist: 0, pointAlpha: 0.14, drift: 0.045 };
      }
      if (settings.scene === "grid"){
        return { ...base, grid:true, linkDist: 120, lineAlpha: 0.08, drift: 0.05 };
      }
      if (settings.scene === "liquid"){
        return { ...base, flow:true, linkDist: 140, lineAlpha: 0.09, drift: 0.06 };
      }
      return base; // space
    }

    function getFx(alpha){ return rgbaFromCssVar("--fx", alpha); }
    function getAccent(alpha){ return rgbaFromCssVar("--accent", alpha); }

    let lastT = performance.now();

    function step(t){
      const dt = Math.min(0.033, (t-lastT)/1000);
      lastT = t;

      // If effects are disabled, skip heavy rendering and just clear canvas (body background remains visible)
      if (settings.disableEffects){
        ctx.clearRect(0,0,w,h);
        requestAnimationFrame(step);
        return;
      }

      if (settings.pauseAnim){
        // Still draw a nice static frame (we keep drawing frame but skip motion updates)
      }

      ctx.clearRect(0,0,w,h);

      // vignette
      const vign = ctx.createRadialGradient(w*0.5, h*0.45, Math.min(w,h)*0.12, w*0.5, h*0.45, Math.max(w,h)*0.75);
      vign.addColorStop(0, "rgba(0,0,0,0)");
      vign.addColorStop(1, "rgba(0,0,0,0.22)");
      ctx.fillStyle = vign;
      ctx.fillRect(0,0,w,h);

      // flash overlay
      if (flash > 0){
        ctx.fillStyle = getAccent(0.18 * flash);
        ctx.fillRect(0,0,w,h);
        flash = Math.max(0, flash - dt*0.9);
      }

      const sp = sceneParams();

      // Grid overlay
      if (sp.grid){
        const size = 48;
        ctx.strokeStyle = getFx(0.04);
        ctx.lineWidth = 1;
        for (let x = 0; x < w; x += size){
          ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke();
        }
        for (let y = 0; y < h; y += size){
          ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke();
        }
      }

      // Night chill / Focus calm factors
      const chill = isNightChillNow() ? 0.55 : 1.0;
      const focusCalm = focusRunning ? 0.55 : 1.0;
      const calm = chill * focusCalm;

      const drift = sp.drift * calm;
      const friction = lerp(0.985, 0.992, calm); // calmer => a bit more friction
      const linkDist = sp.linkDist;
      const linkDist2 = linkDist*linkDist;

      // Flow field (Liquid)
      const flowK = sp.flow ? (0.30 * calm) : 0.0;

      // Waves affect particles
      if (!settings.pauseAnim){
        for (let k = waves.length - 1; k >= 0; k--){
          const wave = waves[k];
          wave.life += dt;
          wave.r += wave.speed * dt;
          const fade = 1 - (wave.life / wave.maxLife);

          for (const p of particles){
            const dx = p.x - wave.x;
            const dy = p.y - wave.y;
            const dist = Math.sqrt(dx*dx+dy*dy) || 1;
            const diff = Math.abs(dist - wave.r);
            if (diff < wave.width){
              const closeness = 1 - (diff / wave.width);
              const kick = wave.strength * closeness * fade;
              p.vx += (dx/dist) * kick * dt * 0.05;
              p.vy += (dy/dist) * kick * dt * 0.05;
            }
          }
          if (wave.life >= wave.maxLife) waves.splice(k,1);
        }
      }

      // Cursor dynamics
      const mode = settings.cursorMode;
      const radius = 190;
      const r2 = radius*radius;

      // Jelly anchor follows mouse
      const jellyAnchor = { x: mouse.x, y: mouse.y };

      for (const p of particles){
        if (settings.pauseAnim){
          // no movement update, but still render later
        } else {
          // very soft random drift
          p.vx += (Math.random()-0.5)*drift*0.002;
          p.vy += (Math.random()-0.5)*drift*0.002;

          // flow field (liquid)
          if (sp.flow){
            const nx = p.x / 120;
            const ny = p.y / 120;
            const ang = Math.sin(nx + t*0.00025) + Math.cos(ny - t*0.00022);
            const fx = Math.cos(ang*2.3) * flowK * 0.18;
            const fy = Math.sin(ang*2.3) * flowK * 0.18;
            p.vx += fx;
            p.vy += fy;
          }

          if (mouse.active){
            const dx = mouse.x - p.x;
            const dy = mouse.y - p.y;
            const d2 = dx*dx + dy*dy;

            if (d2 < r2){
              const d = Math.sqrt(d2) || 1;
              const t0 = 1 - (d / radius); // 0..1

              if (mode === "magnet"){
                const pull = 0.045 * t0 * calm;
                p.vx += (dx/d) * pull;
                p.vy += (dy/d) * pull;
                // sticky damping near mouse
                const damp = 1 - (0.22 * t0);
                p.vx *= damp; p.vy *= damp;
              }

              if (mode === "swirl"){
                const pull = 0.020 * t0 * calm;
                p.vx += (dx/d) * pull;
                p.vy += (dy/d) * pull;
                const swirl = 0.060 * t0 * calm;
                p.vx += (-dy/d) * swirl;
                p.vy += ( dx/d) * swirl;
              }

              if (mode === "repulse"){
                const push = 0.070 * t0 * calm;
                p.vx -= (dx/d) * push;
                p.vy -= (dy/d) * push;
              }

              if (mode === "jelly"){
                // spring toward anchor (mouse) with softness
                // each particle gets a stored anchor offset for a “gel” feeling
                if (!p._jinit){
                  p._jinit = true;
                  p.ax = p.x; p.ay = p.y;
                }
                // target is blended between original anchor and mouse
                const tx = lerp(p.ax, jellyAnchor.x, 0.55);
                const ty = lerp(p.ay, jellyAnchor.y, 0.55);
                const sx = (tx - p.x);
                const sy = (ty - p.y);
                const spring = 0.0045 * (0.5 + t0) * calm;
                p.vx += sx * spring;
                p.vy += sy * spring;
                // extra damping
                p.vx *= (1 - 0.12*t0);
                p.vy *= (1 - 0.12*t0);
              }
            } else if (mode === "jelly"){
              // slowly relax anchors
              if (p._jinit){
                p.ax = lerp(p.ax, p.x, 0.002);
                p.ay = lerp(p.ay, p.y, 0.002);
              }
            }
          }

          // integrate
          p.x += p.vx;
          p.y += p.vy;

          // friction
          p.vx *= friction;
          p.vy *= friction;

          // bounds
          if (p.x < 0) { p.x = 0; p.vx *= -1; }
          if (p.x > w) { p.x = w; p.vx *= -1; }
          if (p.y < 0) { p.y = 0; p.vy *= -1; }
          if (p.y > h) { p.y = h; p.vy *= -1; }
        }
      }

      // Lines (skip in minimal or fog)
      const showLines = sp.lines && !settings.minimal;

      if (showLines && linkDist > 0){
        for (let i=0;i<particles.length;i++){
          const a = particles[i];
          for (let j=i+1;j<particles.length;j++){
            const b = particles[j];
            const dx = a.x - b.x;
            const dy = a.y - b.y;
            const d2 = dx*dx + dy*dy;
            if (d2 < linkDist2){
              const t0 = 1 - (d2 / linkDist2);
              ctx.strokeStyle = getFx(sp.lineAlpha * t0 * calm);
              ctx.lineWidth = 1;
              ctx.beginPath();
              ctx.moveTo(a.x,a.y);
              ctx.lineTo(b.x,b.y);
              ctx.stroke();
            }
          }
        }
      }

      // Points
      for (const p of particles){
        const a = sp.pointAlpha * calm;
        ctx.fillStyle = getFx(a);
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.r * (sp.fog ? 1.35 : 1.0), 0, Math.PI*2);
        ctx.fill();
      }

      // Fog “blur-ish” glow
      if (sp.fog){
        ctx.fillStyle = getFx(0.04);
        ctx.fillRect(0,0,w,h);
      }

      // Draw waves
      for (const wave of waves){
        const fade = 1 - (wave.life / wave.maxLife);
        ctx.strokeStyle = getAccent(0.22 * fade);
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(wave.x, wave.y, wave.r, 0, Math.PI*2);
        ctx.stroke();

        ctx.strokeStyle = getAccent(0.08 * fade);
        ctx.lineWidth = 7;
        ctx.beginPath();
        ctx.arc(wave.x, wave.y, wave.r, 0, Math.PI*2);
        ctx.stroke();
      }

      // Draw waves on hold
      if (!settings.pauseAnim && settings.drawWaves && mouse.down){
        // emit small waves along path
        if (Math.random() < 0.40){
          addWave(mouse.x, mouse.y, 520);
        }
      }

      requestAnimationFrame(step);
    }

    // Reduced motion support
    if (window.matchMedia && window.matchMedia("(prefers-reduced-motion: reduce)").matches){
      settings.pauseAnim = true;
      saveSettings();
    }

    // Start
    applyAll();
    refreshUI();
    requestAnimationFrame((t)=>{ lastT=t; step(t); });
  </script>
</body>
</html>
